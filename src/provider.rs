//! A provider is an object that provides access to a set of cryptographic primitives.
//!
//! A provider generally corresponds to a hardware device like a Trusted Execution Environment (TEE)
//! or a Secure Element (SE).
//!
//! A provider is responsible for the following:
//!
//! - Providing access to a set of cryptographic primitives.
//! - Managing the lifecycle of the cryptographic primitives.
//! - Providing a secure environment for the keys.
//! - Providing a secure environment for the operations.

use crate::error::{Error, Result};
use crate::runes::Schema;
use alloc::{boxed::Box, string::String, vec::Vec};

/// Many cryptographic operations require a variation parameter to be provided.  The variation
/// parameter is a value that is used to vary the behavior of the operation.  Different operations
/// have different requirements for variation parameters.  In some cases they must be unpredictable,
/// in other cases they must be unique and in yet other cases there are no unpredictability or
/// uniqueness requirements.
/// 
/// `VariationType`s are ordered by their difficulty to provide, with  [`VariationType::Arbitrary`]
/// being the easiest to provide because there are no constraints on the values, and
/// [`VariationType::Unique`] being the most difficult since the caller must the guarantee global
/// uniqueness of each value used with the [`crate::provider::BindRune`].  [`VariationType::Random`]
/// is in the middle, since it only requires that the value be generated by a
/// cryptographically-secure random number generator (CPRNG), which is easy to obtain in most
/// environments.
///
/// The [`VariationType`] enum is used to specify the type of a variation parameter that is provided
/// to an operation.  The [`VariationParameter`] struct is used to create variation parameters and
/// is used to pass variation parameters to operations.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum VariationType {
    /// The variation is a value that is not guaranteed to be unique or unpredictable.  This type of
    /// variation is only useful for algorithms like AES-XTS that require tweaks, not nonces or IVs.
    /// Tweak values are often associated with a data object or location, such as a specific block
    /// in a file system or a specific row in a database and needn't be unique or unpredictable.
    /// 
    /// Where a [`VariationType::Arbitrary`] is required, [`VariationType::Random`] and
    /// [`VariationType::Unique`] are both acceptable.
    /// 
    /// Where a [`VariationType::Unique`] is required, [`VariationType::Random`] is often
    /// acceptable, if the maximum number of messages is limited below the birthday bound.
    /// 
    /// Where a [`VariationType::Random`] is required, only [`VariationType::Random`] is acceptable.
    Arbitrary,

    /// The variation is a random value.  Random variations can be used for nonces, but have the
    /// disadvantage of being only probabilistically unique, which means that the number of messages
    /// must be limited below the birthday bound.  They can also be used for IVs which need to be
    /// unpredictable.
    Random,

    /// The variation is a guaranteed-unique value, ideal for nonces, but not usable for IVs which
    /// need to be unpredictable.  A good way to generate a guaranteed-unique value is to use a
    /// counter.
    Unique,
}

/// A variation parameter is a value that is used to vary the behavior of a cryptographic operation.
/// Different operations have different requirements for variation parameters.  See
/// [`VariationType`].
///
/// [`VariationParameter`]s are created by the caller using one of the
/// [`VariationParameter::random`], [`VariationParameter::unique`] or
/// [`VariationParameter::arbitrary`] factory methods.  The user's choice of method constitutes a
/// promise about the uniqueness and predictability of the provided value and it essential that the
/// choice accurately reflects the origin of the provided value.  Choosing incorrectly will
/// compromise the security properties of the operation.
///
/// For example, AES-GCM requires a nonce.  Nonces must be unique but need not be unpredictable.  A
/// random value is acceptable for the nonce but because collisions are possible, a random nonce can
/// only be used for AES-GCM if the [`crate::runes::Rune::MessageLimit`] is 2^32 or less.  Unique
/// nonces do not have this message limit restriction, but it is incumbent on the caller to ensure
/// that the nonce truly is unique for every message, perhaps using a counter to generate them.  A
/// non-random, non-unique value is not acceptable, so a parameter created with
/// [`VariationParameter::arbitrary`] will be rejected.
///
/// In constrast, AES-CBC requires an IV.  IVs must be unpredictable, so a value created with
/// [`VariationParameter::unique`] or [`VariationParameter::arbitrary`] will be rejected.
///
/// AES-XTS requires a tweak.  Tweaks may be predictable and can be repeated, so a tweak should
/// normally be created with [`VariationParameter::arbitrary`], but will also be accepted if created
/// with [`VariationParameter::random`] (meaning randomly generated) or
/// [`VariationParameter::unique`] (meaning guaranteed unique, such as a counter value).
///
/// As long as the caller makes the correct promises about the type of the variation parameter, the
/// security properties of the operation will not be undermined.
#[derive(Debug, Clone)]
pub struct VariationParam {
    data: Vec<u8>,
    variation_type: VariationType,
}

impl VariationParam {
    /// Create a new variation parameter with a value that the caller promises is unique.  If the
    /// value isn't guaranteed to be unique, the security properties of the operation will be
    /// compromised, potentially completely destroying the security of all messages ever processed
    /// by the operation.
    pub fn unique(data: Vec<u8>) -> Self {
        Self { data, variation_type: VariationType::Unique }
    }

    /// Create a new variation parameter with a value that the caller promises was randomly
    /// generated by a cryptographically-secure random number generator (CPRNG).  If the value
    /// wasn't generated by a CPRNG, the security properties of the operation will be compromised,
    /// potentially completely destroying the security of all messages ever processed by the
    /// operation.
    pub fn random(data: Vec<u8>) -> Self {
        Self { data, variation_type: VariationType::Random }
    }

    /// Create a new variation parameter with a value that is not guaranteed to be unique or
    /// unpredictable.
    pub fn arbitrary(data: Vec<u8>) -> Self {
        Self { data, variation_type: VariationType::Arbitrary }
    }
}

type VariationSize = Option<u16>;

/// [`BindRune`] encapsulates cryptographic key material and a defined set of security properties.
/// Applying a `BindRune` to data means applying the security properties of the `BindRune` to the data.
/// This may include encrypting, authenticating, or otherwise protecting the data.
///
/// Unsealing data means removing the security properties of the `BindRune` from the data.
/// This may include decrypting, verifying, or otherwise removing the protection from the data.
///
/// The schema of a `BindRune` is a set of [`Rune`]s that specify the security properties of the
/// `BindRune`.
///
/// [`BindRune`]s are created by the [`Provider::forge`] method.
pub trait BindRune {
    /// Seal data, meaning apply the security properties of the [`BindRune`] to it.
    fn seal(&self) -> Result<Box<dyn Operation>>;

    /// Unseal data, meaning remove the security properties of the [`BindRune`] from it.  This may
    /// include validating integrity and/or authenticity of the data.
    fn unseal(&self) -> Result<Box<dyn Operation>>;

    /// Return the schema of the [`BindRune`].  The schema is a set of [`Rune`]s that specify the
    /// security properties of the [`BindRune`].
    fn schema(&self) -> Schema;
}


pub trait Operation {
    fn variation_size(&self) -> VariationSize;
    fn set_variation(&self, variation: VariationParam) -> Result<()>;

    fn update_aad(&self, aad: &[u8]) -> Result<()>;
    fn finish_aad(&self) -> Result<()>;

    fn update(&self, data: &[u8]) -> Result<Vec<u8>>;
    fn finish(&self, data: &[u8]) -> Result<OperationResult>;
}

#[derive(Debug, Clone)]
pub struct OperationResult {
    pub data: Vec<u8>,
    pub output_parameters: Vec<OutputParameter>,
    pub message_count_remaining: u128,
    pub total_data_remaining: u128,
}

#[derive(Debug, Clone)]
pub enum OutputParameter {
    AuthenticationTag(Vec<u8>),
    Variation(VariationParam),
}

pub trait Provider {
    fn forge(&self, label: &str, desired_properties: Schema) -> Result<Box<dyn BindRune>>;
    fn forge_shareable(
        &self,
        label: &str,
        uuid: u128,
        desired_properties: Schema,
    ) -> Result<Box<dyn BindRune>>;
    fn retrieve(&self, label: &str) -> Result<Box<dyn BindRune>>;
}
